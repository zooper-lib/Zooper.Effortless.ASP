name: Build and Publish

on:
  push:
    branches:
      - main      # Triggers on pushes to main (release)
      - develop   # Triggers on pushes to develop (pre-release)
      - feature/* # Triggers on pushes to feature branches
  workflow_dispatch:

permissions:
  contents: write      # Needed for tagging
  id-token: write      # Optional, based on requirements

env:
  DOTNET_VERSION: '8.x'  # Define the .NET SDK version here

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract_version.outputs.version }}
      package_version: ${{ steps.set_package_version.outputs.package_version }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Fetch all history and tags

      - name: Set up .NET SDK
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Create nupkg Directory
        run: mkdir -p ./nupkg

      - name: Extract Central Version
        id: extract_version
        run: |
          if [ ! -f "Directory.Build.props" ]; then
            echo "Error: Directory.Build.props not found in the repository root."
            exit 1
          fi

          VERSION=$(grep -oP '(?<=<Version>)[^<]+' Directory.Build.props)

          if [ -z "$VERSION" ]; then
            echo "Error: <Version> tag not found in Directory.Build.props."
            exit 1
          fi

          echo "Central Version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Validate Semantic Versioning
        run: |
          VERSION_REGEX="^[0-9]+\.[0-9]+\.[0-9]+$"
          if [[ "${{ env.VERSION }}" =~ $VERSION_REGEX ]]; then
            echo "Version '${{ env.VERSION }}' is valid."
          else
            echo "Error: Version '${{ env.VERSION }}' does not follow semantic versioning (e.g., 1.0.0)."
            exit 1
          fi

      - name: Determine Package Version
        id: set_package_version
        run: |
          # Determine the current branch
          CURRENT_BRANCH="${GITHUB_REF#refs/heads/}"
          echo "Current Branch: $CURRENT_BRANCH"

          # Define release or pre-release based on branch
          if [ "$CURRENT_BRANCH" == "main" ]; then
            IS_PRE_RELEASE="false"
          else
            IS_PRE_RELEASE="true"
          fi

          echo "Is Pre-Release: $IS_PRE_RELEASE"

          if [ "$IS_PRE_RELEASE" == "true" ]; then
            BASE_VERSION="${{ steps.extract_version.outputs.version }}"
            # Fetch all pre-release tags matching the base version
            EXISTING_PRE_RELEASE_TAGS=$(git tag --list "${BASE_VERSION}-preview.*")

            if [ -z "$EXISTING_PRE_RELEASE_TAGS" ]; then
              NEXT_PRE_RELEASE=1
            else
              # Extract numerical parts
              PRE_RELEASE_NUMBERS=$(echo "$EXISTING_PRE_RELEASE_TAGS" | grep -oP '(?<=-preview\.)\d+$')
              MAX_PRE_RELEASE=0
              for num in $PRE_RELEASE_NUMBERS; do
                if [ "$num" -gt "$MAX_PRE_RELEASE" ]; then
                  MAX_PRE_RELEASE=$num
                fi
              done
              NEXT_PRE_RELEASE=$((MAX_PRE_RELEASE + 1))
            fi
            PACKAGE_VERSION="${BASE_VERSION}-preview.${NEXT_PRE_RELEASE}"
          else
            PACKAGE_VERSION="${{ steps.extract_version.outputs.version }}"
          fi

          echo "PACKAGE_VERSION=${PACKAGE_VERSION}" >> $GITHUB_OUTPUT
          echo "package_version=${PACKAGE_VERSION}" >> $GITHUB_OUTPUT

  build-pack-publish:
    needs: setup
    runs-on: ubuntu-latest
    strategy:
      matrix:
        project:
          - ZEA.Api.MVC/ZEA.Api.MVC.csproj
          - ZEA.Api.Swagger/ZEA.Api.Swagger.csproj
          - ZEA.Architecture.Pattern.Mediator.Abstractions/ZEA.Architecture.Pattern.Mediator.Abstractions.csproj
          - ZEA.Architecture.Pattern.Mediator.MediatrWrapper/ZEA.Architecture.Pattern.Mediator.MediatrWrapper.csproj
          - ZEA.Architecture.Pattern.StrongTypes/ZEA.Architecture.Pattern.StrongTypes.csproj
          - ZEA.Architecture.Pattern.StrongTypes.Generator/ZEA.Architecture.Pattern.StrongTypes.Generator.csproj
          - ZEA.Architecture.Patterns.ADTs/ZEA.Architecture.Patterns.ADTs.csproj
          - ZEA.Architecture.Patterns.RailwayOrientedProgramming/ZEA.Architecture.Patterns.RailwayOrientedProgramming.csproj
          - ZEA.Architecture.DDD/ZEA.Architecture.DDD.csproj
          - ZEA.Architecture.EventSourcing/ZEA.Architecture.EventSourcing.csproj
          - ZEA.Architecture.Hexagonal/ZEA.Architecture.Hexagonal.csproj
          - ZEA.Architecture.Modularization/ZEA.Architecture.Modularization.csproj
          - ZEA.Communication.Abstractions/ZEA.Communication.Abstractions.csproj
          - ZEA.Communication.gRPC/ZEA.Communication.gRPC.csproj
          - ZEA.Communication.Messaging.Abstractions/ZEA.Communication.Messaging.Abstractions.csproj
          - ZEA.Communication.Messaging.MassTransit/ZEA.Communication.Messaging.MassTransit.csproj
          - ZEA.Communication.Refit/ZEA.Communication.Refit.csproj
          - ZEA.Configuration.Abstractions/ZEA.Configuration.Abstractions.csproj
          - ZEA.Configuration.AzureKeyVault/ZEA.Configuration.AzureKeyVault.csproj
          - ZEA.Configuration.HashicorpVault/ZEA.Configuration.HashicorpVault.csproj
          - ZEA.Data.Modelling/ZEA.Data.Modelling.csproj
          - ZEA.Serialization.Abstractions/ZEA.Serialization.Abstractions.csproj
          - ZEA.Serialization.NewtonsoftJson/ZEA.Serialization.NewtonsoftJson.csproj
          - ZEA.Validation.Abstractions/ZEA.Validation.Abstractions.csproj
          - ZEA.Validation.FluentValidation/ZEA.Validation.FluentValidation.csproj
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up .NET SDK
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore
        run: dotnet restore "${{ matrix.project }}"

      - name: Build
        run: dotnet build "${{ matrix.project }}" --configuration Release /p:PackageVersion=${{ needs.setup.outputs.package_version }}

      - name: Pack
        run: dotnet pack "${{ matrix.project }}" --configuration Release /p:PackageVersion=${{ needs.setup.outputs.package_version }} --output ./nupkg

      - name: Publish
        run: dotnet nuget push "./nupkg/*.nupkg" --api-key "${{ secrets.NUGET_API_KEY }}" --source https://api.nuget.org/v3/index.json

  tag:
    needs: build-pack-publish
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create and Push Git Tag
        run: |
          PACKAGE_VERSION="${{ needs.setup.outputs.package_version }}"
          
          # Check if tag already exists
          if git rev-parse "$PACKAGE_VERSION" >/dev/null 2>&1; then
            echo "Tag $PACKAGE_VERSION already exists. Skipping tagging."
          else
            git tag "$PACKAGE_VERSION"
            git push origin "$PACKAGE_VERSION"
            echo "Tag $PACKAGE_VERSION created and pushed successfully."
          fi